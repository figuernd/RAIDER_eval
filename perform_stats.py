#!/software/python/3.3.3/bin/python3.3

############################################################################

import argparse
import sys
import re
import Bio
from Bio import SeqIO
from Bio.SeqRecord import SeqRecord
from Bio.Seq import Seq

#def read_repeat_file(rep_file):
#    """ Takes the repeat file generated by repeatmasker and reads each line
#    describing a repeat. Returns a list of tuples (start, end) each corresponding
#    to a repeat R where start is the index of the chromosome sequence where R 
#    begins and end is the index of the chromosome sequence where R ends"""
#    return indices

#def get_repeats(rep_file):
#    """ Takes the repeat file generated by repeatmasker and the original
#    sequence file. Gets a list of the start and end indices of each repeat from
#    masker file and then uses these indices to create a list of the actual
#    repeat sequences. Returns this list and the length of the original sequence."""
#    rf = open(rep_file, 'r')
#    rf.readline()
#    rf.readline()
#    rf.readline()
#    info = []
#    while True:
#        line = rf.readline()
#        if not line:
#            break
#        A = re.split("\s+", line.strip())
#        start = int(A[5]) - 1
#        end = int(A[6])
#        info.append((start, end))
#    return info

def get_sequence_length(rep_file):
    rf = open(rep_file, 'r')
    rf.readline()
    rf.readline()
    rf.readline()
    line = rf.readline()
    # throw exception if not line?
    A = re.split("\s+", line.strip())
    return int(A[6])+int(A[7].strip("()"))


def repeat_bounds_generator(rep_file, exclusion_set=None):
    rf = open(rep_file, 'r')
    rf.readline()
    rf.readline()
    rf.readline()
    while True:
        line = rf.readline()
        if not line:
            break
        if not exclusion_set or (exclusion_set and not any([s in line for s in exclusion_set])):
            A = re.split("\s+", line.strip())
            start = int(A[5]) - 1
            end = int(A[6])
            yield start, end

def add_remaining_mismatches(repeat_bounds_generator, mismatch_list):
    num_bases = 0
    while True:
        try:
            start, end = next(repeat_bounds_generator)
            mismatch_list.append((start, end))
            num_bases += end - start
        except StopIteration:
            break
    return num_bases 
   
def get_stats(real_indices, gen_indices, gen_length):
    """ Takes the real repeats (those expected to be found) and the generated
    repeats (those found by the tool), and uses them to generated performance
    statistics regarding the tool's ability to classify bases as part of repeats
    or not part of repeats. Cutoff is a decimal amount indicating how much of 
    a repeat must match for the bases in it to match"""
    tps, fns, fps = [], [], []
    tp, fn, fp = 0, 0, 0
    leftover_real = False
    leftover_gen = False
    s1, e1 = 0, 0
    s2, e2 = 0, 0
    while True:
        # Only get new indices if nothing leftover to evaluate
        if not leftover_real:
            try:
                s1, e1 = next(real_indices) #[real_indices[0][i] for i in range(2)]   # KARRO: This would be better done as: s1,e1 = real_index[0][:2]
            except StopIteration:
                if leftover_gen:
                    fps.append((s2, e2))
                    fp += e2 - s2
                fp += add_remaining_mismatches(gen_indices, fps)
                break
        if not leftover_gen:
            try:
                s2, e2 = next(gen_indices) #[gen_indices[0][i] for i in range(2)]
            except StopIteration:
                if leftover_real:
                    fns.append((s1, e1))
                    fn += e1 - s1
                fn += add_remaining_mismatches(real_indices, fns)
                break
        leftover_real = False
        leftover_gen = False
        #gen_indices.pop(0)       # This is wrong -- you don't want to pop an repeat until you have accounted for all bases.
        #real_indices.pop(0)      # Suppose: The first real_indices = [[10,20],[30,40]], and gen_indices = [32,38].  You are going to miss the true positives.
        # If they overlap
        if s2 <= e1 and s1 <= e2:
            start_match = s2 if s2 > s1 else s1
            end_match = e2 if e2 < e1 else e1
            tps.append((start_match, end_match))
            tp += end_match - start_match
            if s2 > s1:
                # Missed the real repeat from s1...s2
                fns.append((s1, s2))
                fn += (s2 - s1)
            elif s2 < s1:
                # Falsely identified s2...s1 as a repeat
                fps.append((s2, s1))
                fp += s1 - s2
            if e2 < e1:
                # Next generated repeat might match e2...e1 of real repeat
                leftover_real = True
                s1, e1 = e2, e1 #real_indices.insert(0, (e2,e1))
            elif e2 > e1:
                # e1...e2 of generated repeat match a different real repeat
                leftover_gen = True
                s2, e2 = e1, e2 #gen_indices.insert(0, (e1, e2))
        elif e1 < s2:
            leftover_gen = True
            fns.append((s1, e1))
            fn += e1 - s1
        else:
            fps.append((s2, e2))
            fp += e2 - s2
    tn = gen_length - fp - tp - fn
    tpr, tnr, ppv, npv, fpr, fdr = stats(tp, fp, fn, tn)
    return tp, fp, fn, tn, tpr, tnr, ppv, npv, fpr, fdr, tps, fps, fns

def stats(tp, fp, fn, tn):
    tpr = tp/(tp + fn) if tp + fn > 0 else -1
    tnr = tn/(fp + tn) if fp + tn > 0 else -1
    ppv = tp/(tp + fp) if tp + fp > 0 else -1
    npv = tn/(tn + fn) if tn + fn > 0 else -1
    fpr = 1 - tnr if tnr > -1 else -1
    fdr = 1 - ppv if ppv > -1 else -1
    return tpr, tnr, ppv, npv, fpr, fdr


#def main(seq_file, real_repeats, sim_seq, masker_output, output_file, print_reps):
def main(real_repeats, masker_output, output_file, print_reps, exclusions):
    # assuming masker_repeats references repeats named in consensus_output file
    #orig_record = SeqIO.read(seq_file, "fasta")
    #gen_record = SeqIO.read(sim_seq, "fasta")
    #l = len(gen_record.seq)
    l = get_sequence_length(real_repeats) #len(orig_record.seq)
    
    #real_indices = get_repeats(real_repeats)
    #gen_indices = get_repeats(masker_output)
    if exclusions:
        exclusion_set = {s for line in open(exclusions, "r") for s in re.split("\s+", line.rstrip())}
    else:
        exclusion_set = None
    real_bounds_generator = repeat_bounds_generator(real_repeats, exclusion_set)
    gen_bounds_generator = repeat_bounds_generator(masker_output, exclusion_set)
    tp, fp, fn, tn, tpr, tnr, ppv, npv, fpr, fdr, tps, fps, fns= get_stats(real_bounds_generator, gen_bounds_generator, l) #get_stats(real_indices, gen_indices, l)
 
    f = open(output_file, 'w')
    f.write("TP: %d \n" % (tp))
    f.write("FP: %d \n" % (fp))
    f.write("TN: %d \n" % (tn))
    f.write("FN: %d \n" % (fn))
    f.write("TPR: %f \n" % (tpr))
    f.write("TNR: %f \n" % (tnr))
    f.write("PPV: %f \n" % (ppv))
    f.write("NPV: %f \n" % (npv))
    f.write("FPR: %f \n" % (fpr))
    f.write("FDR: %f \n" % (fdr))
    f.write("\n")
    if print_reps:
        f.write("\nThese bases were correctly identified (true positives):\n")
        f.write('\n'.join('\t(%s %s)' % x for x in tps))
        f.write("\nThese bases were incorrectly identified (false positives):\n")
        f.write('\n'.join('\t(%s %s)' % x for x in fps))
        #for rep in fps:
        #    f.write("\t %s \n" % (str(orig_record.seq[rep[0]:rep[1]]).upper()))
        f.write("\nThese bases were missed (false negatives):\n")
        f.write('\n'.join('\t(%s %s)' % x for x in fns))
        #for rep in fns:
        #    f.write("\t %s \n" %(str(orig_record.seq[rep[0]:rep[1]]).upper()))
    f.close()    

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description = "Generate Sensitivity and Specificity Stats")
    parser.add_argument('-p', '--print_reps', action = "store_true", help = "Print out the repeats", default= False)
    #parser.add_argument("seq_file", help = "Sequence file")
    parser.add_argument('-e', '--exclusion_file', help = "File of repeats to be ignored during analysis", default = None)
    parser.add_argument("repeat_file", help = "Repeats file")
    parser.add_argument("masker_output", help = "Masker output using consensus sequence and sequence file")
    parser.add_argument("output_file", help = "Statistics output file")
    args = parser.parse_args()
    main(args.repeat_file, args.masker_output, args.output_file, args.print_reps, args.exclusion_file)

    


