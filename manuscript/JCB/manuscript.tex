\documentclass[11pt,letterpaper]{amsart}
\usepackage{longtable}
\usepackage{ulem}
\usepackage{authblk}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%\usepackage{algorithmicx}
\usepackage{color}
\def\includegraphic{}
\def\includegraphics{}
\pagestyle{myheadings}

\newcommand{\red}[1]{{\color{red}#1}}
\newcommand{\blue}[1]{{\color{blue}#1}}
\newcommand{\cyan}[1]{{\color{cyan}#1}}
\newcommand{\magenta}[1]{{\color{magenta}#1}}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\usepackage[paper=letterpaper,margin=1.0in]{geometry}

\usepackage[english]{babel}
\usepackage[protrusion=true,expansion=true,final,babel]{microtype}

\title{phRAIDER: Pattern-Hunter based Rapid Ad Initio \\ Identification of Elemenrary Repeats}
\author[1]{Carly E. Schaeffer}
\author[1]{Nathniel D. Figueroa}
\author[2]{Xiaolin Liu}
\author[1,2,3,4]{\\John E. Karro\thanks{Corresponding Author}}
\affil[1]{Department of Computer Science and Software Engineering}
\affil[2]{Cell, Molecular, and Structural Bology}
\affil[3]{Department of Microbiology}
\affil[4]{Department of Statisticcs, Miami University, Oxford, Ohio (USA)}
\renewcommand\Affilfont{\itshape\small}

\newcommand{\comment}[1]{\State \red{\# #1}}

\newtheorem{definition}{Definition}
\newtheorem{observation}{Observation}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}


\date{}

\begin{document}
\maketitle
\abstract{This is the abstract.}

\section*{Introduction}

Transposable Elements (TEs) are genomic sequences that had (or have) the capacity
to insert copies of themselves into other genomic locations, resulting
in homologous families of sequences spread across the genome.  Present
in almost every higher order genome (covering as much as 45\% of the
human genome and 90\% of the maize genome
\cite{Venter:2001p92,SanMiguel:1996wa}), TEs have proved an important
source of data in numerous studies of genomic structure (e.g.
\cite{Arndt:2005p279,Karro:2008p123,Mugal:2009p581,Hardison:2003p97}).
But given their prevalence, it is important for those studying other
aspect the genome to have TEs masked out -- their bases replaced by N
to allow for easy identification and filtering.  Failure to filter can
reek havoc with genomic analysis tools.  For example, unfiltered TEs can trigger
huge numbers of false positives in automated gene finding tool
\cite{Jiang:2013jt}, as well as inflate tool runtime.

The best tools for repeat identification are RepeatMasker and nHMMER
\cite{RepeatMaskerOpen:XkNxXSd7,Wheeler:2013gj}, but both employ
library-based search strategies using a pre-compiled description of
sequences in the family (e.g. an ancestral sequence for BLASTing, or a
profile HMM).  But, much like we ask how the snow plow driver gets to
work \cite{Pratchett:uw}, we must ask how these libraries are
compiled.  Library-based tools are useless for the discovery of new
families, making them difficult to use on newly sequenced or
unannotated genomes. Within mammalian species we can largely rely on
homology relationships to port libraries across species.  This does
not hold so well in plants: in many cases TE composition of a given
plant organism is species-specific.  For example, a rice-based TE
library will only identify 25\% of the TEs in the maize genome
\cite{Jiang:2013jt}.

To solve this problem we turn to {\it de novo} TE identification
tools, identifying TEs using only the genome sequence information.  A
number of such tools are discussed in the literature.  RECON uses
WU-BLAST and PILER using LASTZ to compute self-alignments
\cite{Bao:2002,Edgar:2005p2365,Lopez:2003td,Harris:2007uf}.  RECON
show good sensitivity but is computationally intensive and infeasible
for use on whole genomes (requiring 60 hours for 18Mb rice genome in a
2013 study \cite{Saha:2008dm}), while PILER achieves a good runtime with very low
sensitivity.  ReAS and RepeatScout \cite{Price:2005p1247} are based
on $k$-mer searches, with the earlier showing less sensitivity than
RECON \cite{Li:2005he, Price:2005p1247,Jiang:2013jt}.  RepeatGluer
\cite{Pevzner:2004p3157,Zhi:2006p3199} is based on a variation of
DeBrujin graphs, which allows for a decomposition of TE families into
domains, but is computationally expensive.  In Saha {\it et
  al.} the authors perform an extensive comparison of the tools, and
conclude that RepeatScout is the best tool overall for assembled
genomes, while ReAS the best when dealing with unassembled sequence
fragments \cite{Saha:2008dm}.


\subsection*{Elementary Repeats}
Zheng and Lonardi approached the {\it de novo} identification problem using {\it elementary repeats}
\cite{Zheng:2005bl}.
Similar to the RepeatGluer domains, elementary repeats are
decompositions of TEs into basic building blocks.  Identification of
these building blocks are sufficient for the purpose
of masking, and can be assembled into Transposable Elements for those
interested in TEs themselves.

While it is notoriously difficult to mathematically model transposable
elements \cite{Bao:2002}, elementary repeats are more conducive to a
formal description.  For a given genome, a nucleotide sequence $r$ is
an elementary repeat if: (1) It is of at least length $l$ (the length
requirement); (2) at least $f$ copies of $r$ appear  n the genome (the
frequency requirement) (3) there is no proper substring of $r$ of
length $\leq l$ that appears in the genome independently of $r$ (the
minimality requirement); (4) $r$ is a maximal string w.r.t (1-3) (the
maximality requirement).  Having proposed this definition, Zheng and
Lonardi developed an identification algorithm that had a runtime
quadratic in the query sequence size \cite{Zheng:2005bl}. This was
refined to linear time by He and also by Huo {\it et al.}
\cite{He:2006gpa,Huo:2009hoa} based on variations of suffix tree
approaches, but these appraoches are limited in their ability to handle sequence
variation.  As we are looking a genome size inputs, and TEs
transposable elements naturally suffer from copy mistakes and
accumulate instance-specific base substitutions over time, this is a
significant limitation.

\subsection*{RAIDER}
\label{RAIDERSec}
It was with the objective of creating a linear time identification
algorithm that could handle variation through use of
PatternHunter-like spaced seeds that we developed the prototype RAIDER
\cite{Li:2004wl}.  A rough implementation was first presented in
Figueroa {\it et al.} \cite{Figueroa:2014uk}, with more details in the Figueroa masters
thesis \cite{Figueroa:2013cz}.  RAIDER was built along
an alternate, but equivalent definition of elementary repeats based on
$l$-mers (sequences of length $l$).  Specifically, it was observed
that the minimality condition could be rewritten as: {\it There is no
$l$-mer contained within elementary repeat $r$ that appears in the
genome more times than $r$}.  From there four core observations
that form the basis for the RAIDER algorithm: (1) An $l$-mer cannot
belong to two different elementary repeats; (2) Any $l$-mer in the
genome that occurs $f$ or more times is either an elementary repeat or
belongs to one; (3) any two $l$-mers belonging to an elementary repeat
must appear the same number of times in the genome; (4) If two
sequences in the genome that are {\it maximally identical} (that is,
cannot be extended in either direction and still be identical), these
sequences cannot belong to a larger elementary repeat.  (By ``belong''
we mean ``is a substring of'' -- a definition we will be generalizing
shortly.)  For discussion and proof, see the Figueroa thesis
\cite{Figueroa:2013cz}.

Based on these observations, we discover we can find all elementary
repeats in a single scan of the genome.  Specifically, as we scan from
left to right, we track $l$-mer occurrences and identify multiple
copies of the same $l$-mer.  When we find the same sequence of $l$-mers
occurring multiple times in a row, we can mark it as a tentative family,
then break it down later if we discover violations of the minimality
condition.  

Results of the preliminary implementation were promising. On human
chromosome 22 we saw a $12\times$ speedup over RepeatScout to RAIDER
(2344 seconds to 192 seconds), while coverage of the RepBase
\cite{Jurka:2005bl} ancestral sequence improved (77\% to 84\%).  On
mouse chromosome 19 we saw the same speedup with a significant drop in
coverage (53\% to 30\%).  On the full human genome RAIDER ran in $6.3$
hours, while RepeatScout was unable to complete it run.  

\subsection*{Spaced Seeds}
 
PatternHunter, a very successful augmentation to BLAST
\cite{Li:2004wl,Altschul:1997p843}, is based on the notion of {\it
  spaced seeds}: improving the sensitivity of string matching based
algorthms by allowing wild-cards in the match.  That is, instead of
requiring two strings matching in 12 consecutive characters, we might
instead require two six-character exact matches seperated by one base
which may or may not match (represented by the {\it seed pattern}
11111101111111), or perhaps three consecutive four-character exact
matches sperated by two bases each (1111001111001111). It has been
demonstrated that certain seed patterns can indunce significant
imporvements in BLAST sensitivity without time penalty, though what
makes a good pattern is not well understood.


RAIDER was designed with the intent of employing the spaced seed
strategy, but this was only implemented heuristically for the Figuera
{\it et al.} paper \cite{Figueroa:2013cz} -- serving primarily as a
proof-of-concept.  Since its release we have develoed a formal model
of elementary repeats that incorporated spaced seeds, and from that
developed phRAIDER (PatternHunter-based RAIDER).  phRAIDER is a fast
tool for the identification and making of transposible elements in
both assembled and unassembled genomes aht outpreforms RptScout and
other establihsed tools. Code is free available under the Gnu GPL
lisence (v. 3) and  may be obtained [NEED WEB ADDRESS].  


\section*{Model}

Our goal is to redefine the concept of transposbile elements to
accomodate a spaced seed strategy.   We will start here with a brief
outline of our theoretical model (with a more detailed description in
the appendix), then present the algorithm and results.

We first need to redfine out terminimology regarding elementary
repeats.  Under the Z\&L definition, all instances of one elementary
repeat have the exact same sequence, and hence can be descrbied by a
single string.  As we are allowing for variation, we will describe out
instance set with a {\it sequence descriptor} consisting of bases
letters and the wild-card character * (e.g. AAC*GG would describe a
set of sequences with starting with an AAC, ending with a GG, and
having any character in between).  Given a binary string $s$
representing a spaced seed, we say a sequence descriptor $r$ is
{\it consistent} with $s$ if we can align $s$ to a substring of $r$ such
that every $*$ in $r$ aligns with a $0$ character in $s$. (Hence
$ACG**T*A$ is consistent with the seed $11001$, but not $11011$.) 

Given a sequence descriptor $r$, we can {\it decompose} $r$ with
respect to $s$ by taking every length $|s|$ substring of $r$ that is consistant
with $s$, replacing all letters of $r$ that match to a 0 in $s$ with a
$*$, and creating a set from the results.  (Hence for $s = 11011$ and
$r=AA*CCGTT$, the decomposition would be $\{AA*CC, CC*TT\}$.)  We say
$s$ {\it covers} $r$ if every base in $r$ is contained in at least on
string in the decomposition.  (Hence the previous $s$ does not cover $AAA*CC$, as
the first base in not in any of the strings of the decomposition.)


We can now modify the previous definition of elementary repeats as
follows:
\begin{definition} Given a genomic sequence $G$, an integer $f$, and a
  spaced seed $s$, a sequence descriptor $r$ describes an elementary
  repeat if it meets the four (moified) requirements of an elementary repeat:
\begin{itemize}
\item \underline{Structure requriement}: $s$ covers $r$.
\item \underline{Frequency requirement}: There are at least $f$
  substrings of $G$ that match $r$.
\item \underline{Minimality requirement:} For every string $t$ in the
  decomposition of $r$ w.r.t $s$, the number of occurences of $t$ in
  $G$ is equal to the number of occureneces of $r$ in the genome.
\item \underline{Maximality requirement:} There is no sequence
  descriptor $r'$ of $r$ that contains $r$ as a proper substring and
  satisfies conditions the previous thre conditions.
\end{itemize}
\end{definition}

\begin{theorem} When the seed $s$ has no 0 characters, this
    definition of elementary repeats is equivilent to the Z\&L
    definition.
\end{theorem}

We have written out a proof of this in the appendix.

\subsection*{phRAIDER Algorithm}

We see in Algorithm Pseudocode on the next page a description of the
phRAIDER algorithm, used to find a sequence descriptor for each set of
sequences that comprise an elementary repeat family with respect to
some fixed seed $s$ and minimum frequency threshold $f$. The core idea
behind the algorothm is to find sets of $l$-mers that match w.r.t. the
seed, and whose instances are fixed at a specific spacing internval
between them.  The $H$ dictionary maps each encountered {\it seeded}
$l$-mer (that is, the $l$-mer after removing all characters
corresponding to a 0 in the seed) to a list of genomic locations.
Thus the {\bf sameOffset($v_1$, $v_2$)} can, in constant time, tell us
whterh instances of seed $l$-mers $v_1$ and $v_2$ have the same
distance between their offsets. The loop at line
\algref{phRaider}{mainLoop} takes us through the genome, looking at
each $l$-mer to identify whether it should be grouped with a
recently-seen seen $l$-mer set.  The $Q$ structure holds the candidate
families that $v$ might belong to (any family that we have seen in the
last $s$ bases).  When we look at the seeded $l$-mer $v$ we need to
decide if (1) this is the second occurance of $v$, and hence is the
start of a family, (2) this is the next $l$-mer belonging to a family
we have recently see (seen in the last $|s$ bases, (3) this is the
first $l$-mer of a family not recently seen, or (4) this is an
out-of-place $l$-mer in the midle of the family, implying that family
needs to be broken up.



\begin{algorithm}
\renewcommand\thealgorithm{}
\caption{phRAIDER}
\label{phRaider}
\begin{algorithmic}[1]
  \Function{sameOffset}{$l$-mer $v_1$, $l$-mer $v_2$}
    \comment{Is the distance between the first two occurences of $v$ equal to the}
    \comment{the distance betwen the most recent two occurences?}
    \State \Return $H[v_2][0] - H[v_1][0]  == H[v_2][-1] - H[v_1][-1]$
  \EndFunction
  \State
  \Function{phRAIDER}{Genome $G$, Seed $s$, MinFrequence $f$}
    \comment{We are going to maintain a $Q$ of up to $|s|$ families, representing the families}
    \comment{of the last $|L|$ $l$-mers seen, sorted by the position of those last $l$-mers.}
    \State Queue$<$Family$>$ $Q$; \label{Queue}
    \State
    \comment{Iterate over all $l$-mer positions in $G$}
    \For {$i \leftarrow 1 \to |G|-|s|$}  \label{mainLoop}

       \comment{Remove any families whose last $l$-mer did not occur in the last $i$ bases.}
       \comment{I {\it think} this will never remove more than one element.}
       \While{$i - $location($Q$, finish, last, end)$ > |s|$}
         \State $Q.$dequeue()
       \EndWhile
       \State
       \comment{Get the $l$-mer occuring at $G_i$ and remove letters corresponding to $0$s in $s$.}
       \State $v \leftarrow \mbox{seeded}(G[i],x)$ 
       \State
       \comment{Add to list of $v$'s positions.}
       \State $H[v].push(i)$
       \State
       \If {$|H|(v)| == 2$}
          \comment{$v$ either is the beginning of a family, or should be combined with a}
          \comment{previous $l$-mer to form a family.  (I think we can
            set this up to work in $O(1)$ time.}
          \State $F = \mbox{arg\_find}_{F \in Q}\{\mbox{sameOffset}(F.\mbox{start}(), v)\}$
          \If {$F$}
             \State $Q.$requeue($F$)
          \EndIf
          \State last($Q$).addLmer($v$)   
       \ElsIf {$|H[v]| > 2$}
          \comment{Is $v$ the proper continuation of a family, or does it need to be split off?}
          \State $F \leftarrow v.$family()
          \If {$H[F.\mbox{lastSeen}(i)][-1] < H[Q.\mbox{front}().\mbox{lastSeen}()]$}
              \comment{$v$ belongs to a family whose last instance is too far back.}
              \If {$v \neq F.$first$()$}
                  \comment{$v$ is not the first $l$-mer of its family}
                  \State $F' \leftarrow F.$split($F.v$)
              \Else
                  \State $F' \leftarrow F.$split($F.$lastSeen())
              \EndIf
              \State $Q.$enqueue($F'$)
          \Else
              \If {$v == F.$first()}
                 \comment{$v$ is the first $l$-mer of $F$, so $F$ is moved to the back of $Q$}
                 \State $Q$.requeue($F$)
              \ElsIf {sameOffSet($F.$first(), $v$)}
                 \State $F.$setLastSeen($v$)
              \EndIf
           \EndIf                             
       \EndIf
       \EndFor
       \State
       \comment{Final break up of families as needed; filter families with frequency $\leq f$.}
       \State tieLooseEnds()
  \EndFunction
\end{algorithmic}
\addtocounter{algorithm}{-1}
\end{algorithm}


\bibliographystyle{bmc-mathphys} % Style BST file (bmc-mathphys, vancouver, spbasic).
\bibliography{bmc}      % Bibliography file (usually '*.bib' )



\end{document}
